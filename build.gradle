plugins {
    id 'java'
    id 'com.gradle.build-scan' version '2.2.1'
}

group 'org.gradle'
version '1.0-SNAPSHOT'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    testCompile 'junit:junit:4.12'
}

// TODO: temporary
ext.geServer = System.getProperty('geServer')

// See the Gradle Build Scan User Manual for more information: https://docs.gradle.com/build-scan-plugin/
buildScan {
    // Publish a build scan for each build.
    publishAlways()
    
    // Specify your Gradle Enterprise server, if you have one.
    server = geServer
    
    // If you're not using Gradle Enterprise, agree to the terms of service for use of the public scans server.
    if (geServer == null) {
        termsOfServiceUrl = 'https://gradle.com/terms-of-service'
        termsOfServiceAgree = 'yes'
    }
    
    // With Gradle Enterprise, the build scan plugin v2.1+, and Gradle 5.0+, we can capture hashes of task inputs for
    // use with build comparisons. See https://docs.gradle.com/enterprise/tutorials/task-inputs-comparison/ for more
    // information.
    captureTaskInputFiles = true

    // Tagging builds is a great way to provide additional context on a build scan.
    // If your CI server has an appropriate environment variable exported, you can easily differentiate your CI vs LOCAL
    // builds.
    tag(System.getenv('CI') ? 'CI' : 'LOCAL')
    
    // For Android developers, it can be useful to know whether a build was invoked from Android Studio or from the CLI.
    tag(project.hasProperty('android.injected.invoked.from.ide') ? 'Android Studio' : 'CLI')
    
    // You can also tag your builds based on the build's start parameters.
    tag(gradle.startParameter.buildCacheEnabled ? 'CACHED' : 'NOT_CACHED')
    
    // With build can plugin v1.15+, you can easily add expensive data inside the background {} block. Everything inside
    // here is executed in a separate thread, and guaranteed to complete before finishing the build and publishing the
    // scan.
    background {
        // It's simple to capture values from git. `execAndGetStdout` is a custom method defined below.
        def gitCommitId = execAndGetStdout('git', 'rev-parse', '--verify', 'HEAD')
        def branchName = execAndGetStdout('git', 'rev-parse', '--abbrev-ref', 'HEAD')
        def status = execAndGetStdout('git', 'status', '--porcelain')
        
        // We can add the branch name as either a custom value or a tag, or both.
        if (branchName != null && !branchName.isEmpty() && branchName != 'HEAD') {
            tag branchName
            value 'Git branch name', branchName
        }
        
        // Tracking whether a build is 'dirty' (that is, has uncommitted changes) can be useful when diagnosing 
        // failures.
        if (status != null && !status.isEmpty()) {
            tag 'dirty'
            value 'Git status', status
        }
        
        def commitIdLabel = 'Git Commit ID'
        
        // We can track the commit ID as a custom value
        value commitIdLabel, gitCommitId
        
        // We can also use the git commit ID for generating a custom link, useful in Gradle Enterprise for filtering for 
        // all scans built from the same git commit. This will create a URL that looks like:
        // https://«geServer»/scans?search.names=Git%20Commit%20ID&search.values=«gitCommitId»
        // This pattern can be used for creating custom links for arbitrary key-value pairs that you track with built
        // scan custom values.
        link 'Git commit scans', customValueSearchUrl([(commitIdLabel): gitCommitId])
        
        // Another use for the git commit ID is for generating a custom link to the source in your git repository.
        link 'Source', "https://github.com/gradle/buildscan-snippets/tree/$gitCommitId"
    }
}

def customValueSearchUrl(Map<String, String> search) {
    def query = search.collect { name, value ->
        "search.names=${name.urlEncode()}&search.values=${value.urlEncode()}"
    }.join('&')
    return "$geServer/scans?$query"
}

// This method can be used for executing arbitrary shell processes
def execAndGetStdout(String... args) {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine(args)
        standardOutput = stdout
    }
    return stdout.toString().trim()
}

// An extension method on String
String.metaClass.urlEncode = { -> URLEncoder.encode(delegate as String, 'UTF-8') }